import { memoize } from '../utilities/utils';

function task(func) {
  if (!task.registrationOrder) {
    task.registrationOrder = [];
  }

  func.isTask = true;
  const memoizedFunc = memoize(func);

  task.registrationOrder.push(func.name);

  return function wrapper(...args) {
    const result = memoizedFunc(...args);

    if (!result.name) {
      result.name = func.name;
    }

    return result;
  };
}

function agent(func) {
  func.isAgent = true;
  return memoize(func);
}

function llm(func) {
  func.isLlm = true;
  return memoize(func);
}

function outputJson(cls) {
  cls.isOutputJson = true;
  return cls;
}

function outputPydantic(cls) {
  cls.isOutputPydantic = true;
  return cls;
}

function tool(func) {
  func.isTool = true;
  return memoize(func);
}

function callback(func) {
  func.isCallback = true;
  return memoize(func);
}

function cacheHandler(func) {
  func.isCacheHandler = true;
  return memoize(func);
}

function stage(func) {
  func.isStage = true;
  return memoize(func);
}

function router(func) {
  func.isRouter = true;
  return memoize(func);
}

function pipeline(func) {
  func.isPipeline = true;
  return memoize(func);
}

function crew(func) {
  return function wrapper(self, ...args) {
    const instantiatedTasks = [];
    const instantiatedAgents = [];
    const agentRoles = new Set();

    const allFunctions = Object.getOwnPropertyNames(Object.getPrototypeOf(self))
      .filter(name => typeof self[name] === 'function')
      .reduce((acc, name) => {
        acc[name] = self[name];
        return acc;
      }, {});

    const tasks = Object.entries(allFunctions)
      .filter(([_, func]) => func.isTask)
      .reduce((acc, [name, func]) => {
        acc[name] = func;
        return acc;
      }, {});

    const agents = Object.entries(allFunctions)
      .filter(([_, func]) => func.isAgent)
      .reduce((acc, [name, func]) => {
        acc[name] = func;
        return acc;
      }, {});

    const sortedTaskNames = Object.keys(tasks).sort((a, b) =>
      task.registrationOrder.indexOf(a) - task.registrationOrder.indexOf(b)
    );

    for (const taskName of sortedTaskNames) {
      const taskInstance = tasks[taskName].call(self);
      instantiatedTasks.push(taskInstance);
      if (taskInstance.agent) {
        const agentInstance = taskInstance.agent;
        if (!agentRoles.has(agentInstance.role)) {
          instantiatedAgents.push(agentInstance);
          agentRoles.add(agentInstance.role);
        }
      }
    }

    for (const agentName in agents) {
      const tempAgentInstance = agents[agentName].call(self);
      if (!agentRoles.has(tempAgentInstance.role)) {
        instantiatedAgents.push(tempAgentInstance);
        agentRoles.add(tempAgentInstance.role);
      }
    }

    self.agents = instantiatedAgents;
    self.tasks = instantiatedTasks;

    return func.call(self, ...args);
  };
}

export {
  task,
  agent,
  llm,
  outputJson,
  outputPydantic,
  tool,
  callback,
  cacheHandler,
  stage,
  router,
  pipeline,
  crew
}