import { OutputParser } from 'langchain/output_parsers';
import { OutputParserException } from 'langchain/schema';

class ToolOutputParser extends OutputParser {
  constructor(pydanticObject) {
    super();
    this.pydanticObject = pydanticObject;
  }

  async parse(text) {
    const transformedText = this._transformInValidJson(text);
    let jsonObject;
    try {
      jsonObject = JSON.parse(transformedText);
    } catch (error) {
      throw new OutputParserException(`Failed to parse output as JSON: ${transformedText}`);
    }

    try {
      return this.pydanticObject.parse(jsonObject);
    } catch (error) {
      const name = this.pydanticObject.name;
      const msg = `Failed to parse ${name} from completion ${JSON.stringify(jsonObject)}. Got: ${error.message}`;
      throw new OutputParserException(msg, { llmOutput: jsonObject });
    }
  }

  _transformInValidJson(text) {
    text = text.replace(/```/g, '').replace(/json/g, '');
    const jsonPattern = /\{(?:[^{}]|(?R))*\}/;
    const matches = text.match(new RegExp(jsonPattern, 'g'));

    if (matches) {
      for (const match of matches) {
        try {
          const jsonObj = JSON.parse(match);
          return JSON.stringify(jsonObj);
        } catch (error) {
          // If parsing fails, continue to the next match
          continue;
        }
      }
    }
    return text;
  }

  getFormatInstructions() {
    return "Output should be formatted as a JSON object.";
  }
}

export { ToolOutputParser };