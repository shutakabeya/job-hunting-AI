import { BaseTool } from 'langchain/tools';
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { ToolsHandler } from '../agents/tools_handler';
import { Telemetry } from '../telemetry';
import { ToolCalling, InstructorToolCalling } from './tool_calling';
import { I18N } from '../utilities/i18n';
import { Converter } from '../utilities/converter';
import { Printer } from '../utilities/printer';

class ToolUsageErrorException extends Error {
  constructor(message) {
    super(message);
    this.name = 'ToolUsageErrorException';
  }
}

class ToolUsage {
  constructor(toolsHandler, tools, originalTools, toolsDescription, toolsNames, task, functionCallingLLM, agent, action) {
    this._i18n = new I18N();
    this._printer = new Printer();
    this._telemetry = new Telemetry();
    this._runAttempts = 1;
    this._maxParsingAttempts = 3;
    this._rememberFormatAfterUsages = 3;
    this.agent = agent;
    this.toolsDescription = toolsDescription;
    this.toolsNames = toolsNames;
    this.toolsHandler = toolsHandler;
    this.originalTools = originalTools;
    this.tools = tools;
    this.task = task;
    this.action = action;
    this.functionCallingLLM = functionCallingLLM;

    if (this.functionCallingLLM instanceof ChatOpenAI && this.functionCallingLLM.openai_api_base === null) {
      if (this.functionCallingLLM.model_name === 'gpt-4') {
        this._maxParsingAttempts = 2;
        this._rememberFormatAfterUsages = 4;
      }
    }
  }

  parse(toolString) {
    return this._toolCalling(toolString);
  }

  async use(calling, toolString) {
    if (calling instanceof ToolUsageErrorException) {
      const error = calling.message;
      if (this.agent.verbose) {
        this._printer.print(`\n\n${error}\n`, 'red');
      }
      this.task.incrementToolsErrors();
      return error;
    }

    try {
      const tool = this._selectTool(calling.tool_name);
      return this._use(toolString, tool, calling);
    } catch (e) {
      const error = e.message || String(e);
      this.task.incrementToolsErrors();
      if (this.agent.verbose) {
        this._printer.print(`\n\n${error}\n`, 'red');
      }
      return error;
    }
  }

  // ... (other methods would go here)

  _selectTool(toolName) {
    const orderedTools = this.tools.sort((a, b) => {
      const similarityA = this._stringSimilarity(a.name.toLowerCase().trim(), toolName.toLowerCase().trim());
      const similarityB = this._stringSimilarity(b.name.toLowerCase().trim(), toolName.toLowerCase().trim());
      return similarityB - similarityA;
    });

    for (const tool of orderedTools) {
      if (tool.name.toLowerCase().trim() === toolName.toLowerCase().trim() ||
          this._stringSimilarity(tool.name.toLowerCase().trim(), toolName.toLowerCase().trim()) > 0.85) {
        return tool;
      }
    }

    this.task.incrementToolsErrors();
    if (toolName && toolName !== '') {
      throw new Error(`Action '${toolName}' doesn't exist, these are the only available Actions:\n ${this.toolsDescription}`);
    } else {
      throw new Error(`I forgot the Action name, these are the only available Actions: ${this.toolsDescription}`);
    }
  }

  _stringSimilarity(s1, s2) {
    // Implement a string similarity function here
    // For simplicity, you could use a library like 'string-similarity'
    // or implement a basic Levenshtein distance algorithm
  }

  // ... (other helper methods would go here)
}

export { ToolUsage, ToolUsageErrorException };