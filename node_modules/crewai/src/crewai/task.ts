import { v4 as uuidv4 } from 'uuid';
import { BaseModel, Field } from 'pydantic';
import { BaseAgent } from './agents/agent_builder/base_agent';
import { OutputFormat } from './tasks/output_format';
import { TaskOutput } from './tasks/task_output';
import { Telemetry } from './telemetry/telemetry';
import { Converter, convertToModel } from './utilities/converter';
import { I18N } from './utilities/i18n';

class Task extends BaseModel {
    constructor(data) {
        super();
        this.usedTools = 0;
        this.toolsErrors = 0;
        this.delegations = 0;
        this.i18n = new I18N();
        this.name = data.name || null;
        this.promptContext = data.promptContext || null;
        this.description = data.description;
        this.expectedOutput = data.expectedOutput;
        this.config = data.config || null;
        this.callback = data.callback || null;
        this.agent = data.agent || null;
        this.context = data.context || null;
        this.asyncExecution = data.asyncExecution || false;
        this.outputJson = data.outputJson || null;
        this.outputPydantic = data.outputPydantic || null;
        this.outputFile = data.outputFile || null;
        this.output = data.output || null;
        this.tools = data.tools || [];
        this.id = uuidv4();
        this.humanInput = data.humanInput || false;
        this.converterCls = data.converterCls || null;

        this._telemetry = new Telemetry();
        this._executionSpan = null;
        this._originalDescription = null;
        this._originalExpectedOutput = null;
        this._thread = null;
        this._executionTime = null;

        if (this.config) {
            Object.assign(this, this.config);
        }

        this._checkTools();
        this._checkOutput();
    }

    _setStartExecutionTime() {
        return Date.now() / 1000;
    }

    _setEndExecutionTime(startTime) {
        this._executionTime = Date.now() / 1000 - startTime;
    }

    _checkTools() {
        if (!this.tools.length && this.agent && this.agent.tools) {
            this.tools.push(...this.agent.tools);
        }
    }

    _checkOutput() {
        const outputTypes = [this.outputJson, this.outputPydantic];
        if (outputTypes.filter(Boolean).length > 1) {
            throw new Error("Only one output type can be set, either outputPydantic or outputJson.");
        }
    }

    executeSync(agent = null, context = null, tools = null) {
        return this._executeCore(agent, context, tools);
    }

    get key() {
        const description = this._originalDescription || this.description;
        const expectedOutput = this._originalExpectedOutput || this.expectedOutput;
        const source = [description, expectedOutput];
        return require('crypto').createHash('md5').update(source.join('|')).digest('hex');
    }

    executeAsync(agent = null, context = null, tools = null) {
        return new Promise((resolve) => {
            setTimeout(() => {
                const result = this._executeCore(agent, context, tools);
                resolve(result);
            }, 0);
        });
    }

    _executeCore(agent, context, tools) {
        agent = agent || this.agent;
        this.agent = agent;
        if (!agent) {
            throw new Error(`The task '${this.description}' has no agent assigned, therefore it can't be executed directly and should be executed in a Crew using a specific process that support that, like hierarchical.`);
        }

        const startTime = this._setStartExecutionTime();
        this._executionSpan = this._telemetry.taskStarted(agent.crew, this);

        this.promptContext = context;
        tools = tools || this.tools || [];

        const result = agent.executeTask(this, context, tools);

        const [pydanticOutput, jsonOutput] = this._exportOutput(result);

        const taskOutput = new TaskOutput({
            name: this.name,
            description: this.description,
            expectedOutput: this.expectedOutput,
            raw: result,
            pydantic: pydanticOutput,
            jsonDict: jsonOutput,
            agent: agent.role,
            outputFormat: this._getOutputFormat(),
        });
        this.output = taskOutput;

        this._setEndExecutionTime(startTime);
        if (this.callback) {
            this.callback(this.output);
        }

        if (this._executionSpan) {
            this._telemetry.taskEnded(this._executionSpan, this, agent.crew);
            this._executionSpan = null;
        }

        if (this.outputFile) {
            const content = jsonOutput || (pydanticOutput ? JSON.stringify(pydanticOutput) : result);
            this._saveFile(content);
        }

        return taskOutput;
    }

    prompt() {
        const tasksSlices = [this.description];
        const output = this.i18n.slice("expected_output").format({
            expectedOutput: this.expectedOutput
        });
        tasksSlices.push(output);
        return tasksSlices.join('\n');
    }

    interpolateInputs(inputs) {
        if (!this._originalDescription) {
            this._originalDescription = this.description;
        }
        if (!this._originalExpectedOutput) {
            this._originalExpectedOutput = this.expectedOutput;
        }

        if (inputs) {
            this.description = this._originalDescription.replace(/\{(\w+)\}/g, (_, key) => inputs[key] || '');
            this.expectedOutput = this._originalExpectedOutput.replace(/\{(\w+)\}/g, (_, key) => inputs[key] || '');
        }
    }

    incrementToolsErrors() {
        this.toolsErrors += 1;
    }

    incrementDelegations() {
        this.delegations += 1;
    }

    copy(agents) {
        const exclude = ['id', 'agent', 'context', 'tools'];
        const copiedData = Object.fromEntries(
            Object.entries(this)
                .filter(([key, value]) => !exclude.includes(key) && value !== null)
        );

        const clonedContext = this.context ? this.context.map(task => task.copy(agents)) : null;

        const getAgentByRole = (role) => agents.find(agent => agent.role === role);

        const clonedAgent = this.agent ? getAgentByRole(this.agent.role) : null;
        const clonedTools = this.tools ? [...this.tools] : [];

        return new Task({
            ...copiedData,
            context: clonedContext,
            agent: clonedAgent,
            tools: clonedTools,
        });
    }

    _exportOutput(result) {
        let pydanticOutput = null;
        let jsonOutput = null;

        if (this.outputPydantic || this.outputJson) {
            const modelOutput = convertToModel(
                result,
                this.outputPydantic,
                this.outputJson,
                this.agent,
                this.converterCls
            );

            if (modelOutput instanceof BaseModel) {
                pydanticOutput = modelOutput;
            } else if (typeof modelOutput === 'object') {
                jsonOutput = modelOutput;
            } else if (typeof modelOutput === 'string') {
                try {
                    jsonOutput = JSON.parse(modelOutput);
                } catch (error) {
                    jsonOutput = null;
                }
            }
        }

        return [pydanticOutput, jsonOutput];
    }

    _getOutputFormat() {
        if (this.outputJson) return OutputFormat.JSON;
        if (this.outputPydantic) return OutputFormat.PYDANTIC;
        return OutputFormat.RAW;
    }

    _saveFile(result) {
        if (!this.outputFile) {
            throw new Error("output_file is not set.");
        }

        const fs = require('fs');
        const path = require('path');
        const directory = path.dirname(this.outputFile);

        if (directory && !fs.existsSync(directory)) {
            fs.mkdirSync(directory, { recursive: true });
        }

        if (typeof result === 'object') {
            fs.writeFileSync(this.outputFile, JSON.stringify(result, null, 2), 'utf-8');
        } else {
            fs.writeFileSync(this.outputFile, result.toString(), 'utf-8');
        }
    }

    toString() {
        return `Task(description=${this.description}, expectedOutput=${this.expectedOutput})`;
    }
}

export { Task };