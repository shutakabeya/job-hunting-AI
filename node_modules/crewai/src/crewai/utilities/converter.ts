import { HumanMessage, SystemMessage } from 'langchain/schema';
import { ChatOpenAI } from 'langchain/chat_models/openai';
import { BaseOutputConverter } from '../agents/agent_builder/utilities/base_output_converter';
import { Printer } from './printer';
import { PydanticSchemaParser } from './pydantic_schema_parser';
import { CrewPydanticOutputParser } from './crew_pydantic_output_parser';
import { Instructor } from './instructor';

class ConverterError extends Error {
    constructor(message) {
        super(message);
        this.name = 'ConverterError';
    }
}

class Converter extends BaseOutputConverter {
    constructor({ llm, text, model, instructions, maxAttempts = 3 }) {
        super();
        this.llm = llm;
        this.text = text;
        this.model = model;
        this.instructions = instructions;
        this.maxAttempts = maxAttempts;
        this.isGpt = llm instanceof ChatOpenAI && llm.openai_api_base === null;
    }

    async toPydantic(currentAttempt = 1) {
        try {
            if (this.isGpt) {
                return await this._createInstructor().toPydantic();
            } else {
                return await this._createChain().invoke({});
            }
        } catch (e) {
            if (currentAttempt < this.maxAttempts) {
                return this.toPydantic(currentAttempt + 1);
            }
            return new ConverterError(`Failed to convert text into a pydantic model due to the following error: ${e}`);
        }
    }

    async toJson(currentAttempt = 1) {
        try {
            if (this.isGpt) {
                return await this._createInstructor().toJson();
            } else {
                const result = await this._createChain().invoke({});
                return JSON.stringify(result);
            }
        } catch (e) {
            if (currentAttempt < this.maxAttempts) {
                return this.toJson(currentAttempt + 1);
            }
            return new ConverterError(`Failed to convert text into JSON, error: ${e}.`);
        }
    }

    _createInstructor() {
        return new Instructor({
            llm: this.llm,
            maxAttempts: this.maxAttempts,
            model: this.model,
            content: this.text,
            instructions: this.instructions,
        });
    }

    _createChain() {
        const parser = new CrewPydanticOutputParser(this.model);
        const newPrompt = new SystemMessage({ content: this.instructions }).concat(
            new HumanMessage({ content: this.text })
        );
        return newPrompt.pipe(this.llm).pipe(parser);
    }
}

function convertToModel(result, outputPydantic, outputJson, agent, converterCls = null) {
    const model = outputPydantic || outputJson;
    if (!model) {
        return result;
    }

    try {
        const escapedResult = JSON.stringify(JSON.parse(result));
        return validateModel(escapedResult, model, Boolean(outputJson));
    } catch (e) {
        if (e instanceof SyntaxError) {
            new Printer().print(`Error parsing JSON: ${e}. Attempting to handle partial JSON.`, 'yellow');
            return handlePartialJson(result, model, Boolean(outputJson), agent, converterCls);
        } else if (e instanceof Error) {
            new Printer().print(`Pydantic validation error: ${e}. Attempting to handle partial JSON.`, 'yellow');
            return handlePartialJson(result, model, Boolean(outputJson), agent, converterCls);
        } else {
            new Printer().print(`Unexpected error during model conversion: ${e}. Returning original result.`, 'red');
            return result;
        }
    }
}

function validateModel(result, model, isJsonOutput) {
    const exportedResult = model.parse(JSON.parse(result));
    return isJsonOutput ? exportedResult : JSON.stringify(exportedResult);
}

function handlePartialJson(result, model, isJsonOutput, agent, converterCls) {
    const match = result.match(/({.*})/s);
    if (match) {
        try {
            const exportedResult = model.parse(JSON.parse(match[0]));
            return isJsonOutput ? exportedResult : JSON.stringify(exportedResult);
        } catch (e) {
            new Printer().print(`Error handling partial JSON: ${e}. Attempting alternative conversion method.`, 'yellow');
        }
    }
    return convertWithInstructions(result, model, isJsonOutput, agent, converterCls);
}

function convertWithInstructions(result, model, isJsonOutput, agent, converterCls) {
    const llm = agent.functionCallingLLM || agent.llm;
    const instructions = getConversionInstructions(model, llm);

    const converter = createConverter({
        agent,
        converterCls,
        llm,
        text: result,
        model,
        instructions,
    });

    const exportedResult = isJsonOutput ? converter.toJson() : converter.toPydantic();

    if (exportedResult instanceof ConverterError) {
        new Printer().print(`${exportedResult.message} Using raw output instead.`, 'red');
        return result;
    }

    return exportedResult;
}

function getConversionInstructions(model, llm) {
    let instructions = "I'm gonna convert this raw text into valid JSON.";
    if (!isGpt(llm)) {
        const modelSchema = new PydanticSchemaParser(model).getSchema();
        instructions = `${instructions}\n\nThe json should have the following structure, with the following keys:\n${modelSchema}`;
    }
    return instructions;
}

function isGpt(llm) {
    return llm instanceof ChatOpenAI && llm.openai_api_base === null;
}

function createConverter({ agent = null, converterCls = null, ...args }) {
    if (agent && !converterCls) {
        if (typeof agent.getOutputConverter === 'function') {
            return agent.getOutputConverter(args);
        } else {
            throw new Error("Agent does not have a 'getOutputConverter' method");
        }
    } else if (converterCls) {
        return new converterCls(args);
    } else {
        throw new Error("Either agent or converterCls must be provided");
    }
}

export {
    Converter,
    ConverterError,
    convertToModel,
    createConverter,
};