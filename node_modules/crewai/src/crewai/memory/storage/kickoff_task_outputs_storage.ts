import sqlite3 from 'sqlite3';
import { open } from 'sqlite';
import { Printer } from '../../utilities/printer';
import { CrewJSONEncoder } from '../../utilities/crew_json_encoder';
import { dbStoragePath } from '../../utilities/paths';

class KickoffTaskOutputsSQLiteStorage {
    constructor(dbPath = `${dbStoragePath()}/latest_kickoff_task_outputs.db`) {
        this.dbPath = dbPath;
        this._printer = new Printer();
        this._initializeDb();
    }

    async _initializeDb() {
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.Database
            });

            await db.exec(`
        CREATE TABLE IF NOT EXISTS latest_kickoff_task_outputs (
          task_id TEXT PRIMARY KEY,
          expected_output TEXT,
          output JSON,
          task_index INTEGER,
          inputs JSON,
          was_replayed BOOLEAN,
          timestamp DATETIME DEFAULT CURRENT_TIMESTAMP
        )
      `);

            await db.close();
        } catch (e) {
            this._printer.print(
                `SAVING KICKOFF TASK OUTPUTS ERROR: An error occurred during database initialization: ${e}`,
                'red'
            );
        }
    }

    async add(task, output, taskIndex, wasReplayed = false, inputs = {}) {
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.Database
            });

            await db.run(
                `INSERT OR REPLACE INTO latest_kickoff_task_outputs
        (task_id, expected_output, output, task_index, inputs, was_replayed)
        VALUES (?, ?, ?, ?, ?, ?)`,
                [
                    task.id.toString(),
                    task.expected_output,
                    JSON.stringify(output, CrewJSONEncoder.replacer),
                    taskIndex,
                    JSON.stringify(inputs),
                    wasReplayed
                ]
            );

            await db.close();
        } catch (e) {
            this._printer.print(
                `SAVING KICKOFF TASK OUTPUTS ERROR: An error occurred during database initialization: ${e}`,
                'red'
            );
        }
    }

    async update(taskIndex, kwargs) {
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.Database
            });

            const fields = [];
            const values = [];
            for (const [key, value] of Object.entries(kwargs)) {
                fields.push(`${key} = ?`);
                values.push(typeof value === 'object' ? JSON.stringify(value, CrewJSONEncoder.replacer) : value);
            }

            const query = `UPDATE latest_kickoff_task_outputs SET ${fields.join(', ')} WHERE task_index = ?`;
            values.push(taskIndex);

            const result = await db.run(query, values);

            if (result.changes === 0) {
                this._printer.print(
                    `No row found with task_index ${taskIndex}. No update performed.`,
                    'red'
                );
            }

            await db.close();
        } catch (e) {
            this._printer.print(`UPDATE KICKOFF TASK OUTPUTS ERROR: ${e}`, 'red');
        }
    }

    async load() {
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.Database
            });

            const rows = await db.all(`
        SELECT *
        FROM latest_kickoff_task_outputs
        ORDER BY task_index
      `);

            await db.close();

            return rows.map(row => ({
                task_id: row.task_id,
                expected_output: row.expected_output,
                output: JSON.parse(row.output),
                task_index: row.task_index,
                inputs: JSON.parse(row.inputs),
                was_replayed: row.was_replayed,
                timestamp: row.timestamp
            }));
        } catch (e) {
            this._printer.print(
                `LOADING KICKOFF TASK OUTPUTS ERROR: An error occurred while querying kickoff task outputs: ${e}`,
                'red'
            );
            return null;
        }
    }

    async deleteAll() {
        try {
            const db = await open({
                filename: this.dbPath,
                driver: sqlite3.Database
            });

            await db.run('DELETE FROM latest_kickoff_task_outputs');

            await db.close();
        } catch (e) {
            this._printer.print(
                `ERROR: Failed to delete all kickoff task outputs: ${e}`,
                'red'
            );
        }
    }
}

export { KickoffTaskOutputsSQLiteStorage };