import os from 'os';
import path from 'path';
import fs from 'fs-extra';
import { App } from 'embedchain';
import { Storage } from './interface';
import { dbStoragePath } from '../../utilities/paths';

class FakeLLM {
  // Implement FakeLLM if needed
}

class RAGStorage extends Storage {
  constructor(type, allowReset = true, embedderConfig = null, crew = null) {
    super();
    if (!process.env.OPENAI_API_KEY && process.env.OPENAI_BASE_URL !== "https://api.openai.com/v1") {
      process.env.OPENAI_API_KEY = "fake";
    }

    const agents = crew ? crew.agents.map(agent => this._sanitizeRole(agent.role)).join('_') : '';

    const config = {
      app: {
        config: { name: type, collect_metrics: false, log_level: "ERROR" }
      },
      chunker: {
        chunk_size: 5000,
        chunk_overlap: 100,
        length_function: "len",
        min_chunk_size: 150,
      },
      vectordb: {
        provider: "chroma",
        config: {
          collection_name: type,
          dir: path.join(dbStoragePath(), type, agents),
          allow_reset: allowReset,
        },
      },
    };

    if (embedderConfig) {
      config.embedder = embedderConfig;
    }

    this.type = type;
    this.app = App.fromConfig(config);
    this.app.llm = new FakeLLM();
    if (allowReset) {
      this.app.reset();
    }
  }

  _sanitizeRole(role) {
    return role.replace(/\n/g, '').replace(/ /g, '_').replace(/\//g, '_');
  }

  save(value, metadata) {
    this._generateEmbedding(value, metadata);
  }

  search(query, limit = 3, filter = null, scoreThreshold = 0.35) {
    try {
      const results = filter
        ? this.app.search(query, limit, { where: filter })
        : this.app.search(query, limit);
      return results.filter(r => r.metadata.score >= scoreThreshold);
    } catch (error) {
      if (error.name === 'InvalidDimensionException') {
        this.app.reset();
        return [];
      }
      throw error;
    }
  }

  _generateEmbedding(text, metadata) {
    this.app.add(text, { data_type: "TEXT", metadata });
  }

  reset() {
    try {
      fs.removeSync(path.join(dbStoragePath(), this.type));
    } catch (e) {
      throw new Error(`An error occurred while resetting the ${this.type} memory: ${e}`);
    }
  }
}

export { RAGStorage };