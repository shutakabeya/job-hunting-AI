import z from 'zod';
import { OutputFormat } from './output_format';

const TaskOutput = z.object({
  description: z.string().describe("Description of the task"),
  name: z.string().optional().describe("Name of the task"),
  expected_output: z.string().optional().describe("Expected output of the task"),
  summary: z.string().optional().describe("Summary of the task"),
  raw: z.string().describe("Raw output of the task").default(""),
  pydantic: z.any().optional().describe("Pydantic output of task"),
  json_dict: z.record(z.any()).optional().describe("JSON dictionary of task"),
  agent: z.string().describe("Agent that executed the task"),
  output_format: z.nativeEnum(OutputFormat).describe("Output format of the task").default(OutputFormat.RAW)
});

class TaskOutputClass {
  constructor(data) {
    const validatedData = TaskOutput.parse(data);
    Object.assign(this, validatedData);
    if (!this.summary) {
      const excerpt = this.description.split(" ").slice(0, 10).join(" ");
      this.summary = `${excerpt}...`;
    }
  }

  get json() {
    if (this.output_format !== OutputFormat.JSON) {
      throw new Error(
        "Invalid output format requested. If you would like to access the JSON output, please make sure to set the output_json property for the task"
      );
    }
    return JSON.stringify(this.json_dict);
  }

  toDict() {
    const output_dict = {};
    if (this.json_dict) {
      Object.assign(output_dict, this.json_dict);
    } else if (this.pydantic) {
      Object.assign(output_dict, this.pydantic);
    }
    return output_dict;
  }

  toString() {
    if (this.pydantic) {
      return JSON.stringify(this.pydantic);
    }
    if (this.json_dict) {
      return JSON.stringify(this.json_dict);
    }
    return this.raw;
  }
}

export { TaskOutput: TaskOutputClass };