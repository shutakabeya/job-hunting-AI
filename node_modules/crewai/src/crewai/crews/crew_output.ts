import z from 'zod';
import { OutputFormat } from '../tasks/output_format';
import { TaskOutput } from '../tasks/task_output';
import { UsageMetrics } from '../types/usage_metrics';

const CrewOutput = z.object({
  raw: z.string().describe("Raw output of crew").default(""),
  pydantic: z.any().optional().describe("Pydantic output of Crew"),
  json_dict: z.record(z.any()).optional().describe("JSON dict output of Crew"),
  tasks_output: z.array(z.instanceof(TaskOutput)).describe("Output of each task").default([]),
  token_usage: z.instanceof(UsageMetrics).describe("Processed token summary").default(new UsageMetrics({})),
});

class CrewOutputClass {
  constructor(data) {
    const validatedData = CrewOutput.parse(data);
    Object.assign(this, validatedData);
  }

  get json() {
    if (this.tasks_output[this.tasks_output.length - 1].output_format !== OutputFormat.JSON) {
      throw new Error(
        "No JSON output found in the final task. Please make sure to set the output_json property in the final task in your crew."
      );
    }

    return JSON.stringify(this.json_dict);
  }

  toDict() {
    const output_dict = {};
    if (this.json_dict) {
      Object.assign(output_dict, this.json_dict);
    } else if (this.pydantic) {
      Object.assign(output_dict, this.pydantic);
    }
    return output_dict;
  }

  toString() {
    if (this.pydantic) {
      return JSON.stringify(this.pydantic);
    }
    if (this.json_dict) {
      return JSON.stringify(this.json_dict);
    }
    return this.raw;
  }
}

export { CrewOutput: CrewOutputClass };