"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.EmbedChainApp = void 0;
const fs = __importStar(require("fs"));
const document_1 = require("langchain/document");
const openai_1 = __importDefault(require("openai"));
const path = __importStar(require("path"));
const uuid_1 = require("uuid");
const chunkers_1 = require("./chunkers");
const loaders_1 = require("./loaders");
const vectordb_1 = require("./vectordb");
const openai = new openai_1.default({
    apiKey: process.env.OPENAI_API_KEY,
});
class EmbedChain {
    constructor(db, collectMetrics = true) {
        this.userAsks = [];
        if (!db) {
            this.initApp = this.setupChroma();
        }
        else {
            this.initApp = this.setupOther(db);
        }
        this.collectMetrics = collectMetrics;
        // Send anonymous telemetry
        this.sId = (0, uuid_1.v4)();
        this.sendTelemetryEvent('init');
    }
    setupChroma() {
        return __awaiter(this, void 0, void 0, function* () {
            const db = new vectordb_1.ChromaDB();
            yield db.initDb;
            this.dbClient = db.client;
            if (db.collection) {
                this.collection = db.collection;
            }
            else {
                // TODO: Add proper error handling
                console.error('No collection');
            }
        });
    }
    setupOther(db) {
        return __awaiter(this, void 0, void 0, function* () {
            yield db.initDb;
            // TODO: Figure out how we can initialize an unknown database.
            // this.dbClient = db.client;
            // this.collection = db.collection;
            this.userAsks = [];
        });
    }
    static getLoader(dataType) {
        const loaders = {
            pdf_file: new loaders_1.PdfFileLoader(),
            web_page: new loaders_1.WebPageLoader(),
            qna_pair: new loaders_1.LocalQnaPairLoader(),
        };
        return loaders[dataType];
    }
    static getChunker(dataType) {
        const chunkers = {
            pdf_file: new chunkers_1.PdfFileChunker(),
            web_page: new chunkers_1.WebPageChunker(),
            qna_pair: new chunkers_1.QnaPairChunker(),
        };
        return chunkers[dataType];
    }
    add(dataType, url) {
        return __awaiter(this, void 0, void 0, function* () {
            const loader = EmbedChain.getLoader(dataType);
            const chunker = EmbedChain.getChunker(dataType);
            this.userAsks.push([dataType, url]);
            const { documents, countNewChunks } = yield this.loadAndEmbed(loader, chunker, url);
            if (this.collectMetrics) {
                const wordCount = documents.reduce((sum, document) => sum + document.split(' ').length, 0);
                this.sendTelemetryEvent('add', {
                    data_type: dataType,
                    word_count: wordCount,
                    chunks_count: countNewChunks,
                });
            }
        });
    }
    addLocal(dataType, content) {
        return __awaiter(this, void 0, void 0, function* () {
            const loader = EmbedChain.getLoader(dataType);
            const chunker = EmbedChain.getChunker(dataType);
            this.userAsks.push([dataType, content]);
            const { documents, countNewChunks } = yield this.loadAndEmbed(loader, chunker, content);
            if (this.collectMetrics) {
                const wordCount = documents.reduce((sum, document) => sum + document.split(' ').length, 0);
                this.sendTelemetryEvent('add_local', {
                    data_type: dataType,
                    word_count: wordCount,
                    chunks_count: countNewChunks,
                });
            }
        });
    }
    loadAndEmbed(loader, chunker, src) {
        return __awaiter(this, void 0, void 0, function* () {
            const embeddingsData = yield chunker.createChunks(loader, src);
            let { documents, ids, metadatas } = embeddingsData;
            const existingDocs = yield this.collection.get({ ids });
            const existingIds = new Set(existingDocs.ids);
            if (existingIds.size > 0) {
                const dataDict = {};
                for (let i = 0; i < ids.length; i += 1) {
                    const id = ids[i];
                    if (!existingIds.has(id)) {
                        dataDict[id] = { doc: documents[i], meta: metadatas[i] };
                    }
                }
                if (Object.keys(dataDict).length === 0) {
                    console.log(`All data from ${src} already exists in the database.`);
                    return { documents: [], metadatas: [], ids: [], countNewChunks: 0 };
                }
                ids = Object.keys(dataDict);
                const dataValues = Object.values(dataDict);
                documents = dataValues.map(({ doc }) => doc);
                metadatas = dataValues.map(({ meta }) => meta);
            }
            const countBeforeAddition = yield this.count();
            yield this.collection.add({ documents, metadatas, ids });
            const countNewChunks = (yield this.count()) - countBeforeAddition;
            console.log(`Successfully saved ${src}. New chunks count: ${countNewChunks}`);
            return { documents, metadatas, ids, countNewChunks };
        });
    }
    static formatResult(results) {
        return __awaiter(this, void 0, void 0, function* () {
            return results.documents[0].map((document, index) => {
                const metadata = results.metadatas[0][index] || {};
                // TODO: Add proper error handling
                const distance = results.distances ? results.distances[0][index] : null;
                return [new document_1.Document({ pageContent: document, metadata }), distance];
            });
        });
    }
    static getOpenAiAnswer(prompt) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const messages = [
                { role: 'user', content: prompt },
            ];
            const response = yield openai.chat.completions.create({
                model: 'gpt-3.5-turbo',
                messages,
                temperature: 0,
                max_tokens: 1000,
                top_p: 1,
            });
            return ((_b = (_a = response.choices[0].message) === null || _a === void 0 ? void 0 : _a.content) !== null && _b !== void 0 ? _b : 'Response could not be processed.');
        });
    }
    retrieveFromDatabase(inputQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const result = yield this.collection.query({
                nResults: 1,
                queryTexts: [inputQuery],
            });
            const resultFormatted = yield EmbedChain.formatResult(result);
            const content = resultFormatted[0][0].pageContent;
            return content;
        });
    }
    static generatePrompt(inputQuery, context) {
        const prompt = `Use the following pieces of context to answer the query at the end. If you don't know the answer, just say that you don't know, don't try to make up an answer.\n${context}\nQuery: ${inputQuery}\nHelpful Answer:`;
        return prompt;
    }
    static getAnswerFromLlm(prompt) {
        return __awaiter(this, void 0, void 0, function* () {
            const answer = yield EmbedChain.getOpenAiAnswer(prompt);
            return answer;
        });
    }
    query(inputQuery) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.retrieveFromDatabase(inputQuery);
            const prompt = EmbedChain.generatePrompt(inputQuery, context);
            const answer = yield EmbedChain.getAnswerFromLlm(prompt);
            this.sendTelemetryEvent('query');
            return answer;
        });
    }
    dryRun(input_query) {
        return __awaiter(this, void 0, void 0, function* () {
            const context = yield this.retrieveFromDatabase(input_query);
            const prompt = EmbedChain.generatePrompt(input_query, context);
            return prompt;
        });
    }
    /**
     * Count the number of embeddings.
     * @returns {Promise<number>}: The number of embeddings.
     */
    count() {
        return this.collection.count();
    }
    sendTelemetryEvent(method, extraMetadata) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.collectMetrics) {
                return;
            }
            const url = 'https://api.embedchain.ai/api/v1/telemetry/';
            // Read package version from filesystem (because it's not in the ts root dir)
            const packageJsonPath = path.join(__dirname, '..', 'package.json');
            const packageJson = JSON.parse(fs.readFileSync(packageJsonPath, 'utf8'));
            const metadata = Object.assign({ s_id: this.sId, version: packageJson.version, method, language: 'js' }, extraMetadata);
            const maxRetries = 3;
            // Retry the fetch
            for (let i = 0; i < maxRetries; i += 1) {
                try {
                    // eslint-disable-next-line no-await-in-loop
                    const response = yield fetch(url, {
                        method: 'POST',
                        body: JSON.stringify({ metadata }),
                    });
                    if (response.ok) {
                        // Break out of the loop if the request was successful
                        break;
                    }
                    else {
                        // Log the unsuccessful response (optional)
                        console.error(`Telemetry: Attempt ${i + 1} failed with status:`, response.status);
                    }
                }
                catch (error) {
                    // Log the error (optional)
                    console.error(`Telemetry: Attempt ${i + 1} failed with error:`, error);
                }
                // If this was the last attempt, throw an error or handle the failure
                if (i === maxRetries - 1) {
                    console.error('Telemetry: Max retries reached');
                }
            }
        });
    }
}
class EmbedChainApp extends EmbedChain {
}
exports.EmbedChainApp = EmbedChainApp;
//# sourceMappingURL=embedchain.js.map